use image::GrayImage;
use clap::{Arg, Command, ArgAction};
use std::fs::File;
use csv::ReaderBuilder;

fn decompress_pixel_data(pixel_data: u8) -> u8 {
    (pixel_data as u16 * 255 / 15) as u8
}

fn reconstruct_image(csv_path: &str, width: u32, height: u32, decompress: bool, output_path: &str) {
    let mut image = GrayImage::new(width, height);

    let file = File::open(csv_path).expect("Failed to open CSV file");
    let mut rdr = ReaderBuilder::new().has_headers(false).from_reader(file);

    for result in rdr.records() {
        let record = result.expect("Failed to read CSV record");
        if record.len() == 2 {
            let position: Vec<usize> = record[0]
                .split('_')
                .skip(1)
                .map(|s| s.parse().unwrap())
                .collect();

            // out_row_column --> out_height_width
            if position.len() == 2 {
                let h = (position[0] - 1) as u32;
                let w = (position[1] - 1) as u32;
                let mut value: u8 = record[1].trim().parse().expect("Failed to parse pixel value");
                if decompress {
                    value = decompress_pixel_data(value);
                }
                image.put_pixel(w, h, image::Luma([value]));
            }
        }
    }

    image.save(output_path).expect("Failed to save image to file");

    println!("Image written at {}", output_path);
}

fn main() {
    let matches = Command::new("Postprocess Blur Filter")
        .about("Postprocess decrypted server outputs to recover blurred image")
        .arg(
            Arg::new("decrypted-outputs")
                .long("decrypted-outputs")
                .value_name("FILE")
                .help("CSV file with the output wires generated by HELM")
                .required(true)
                .value_parser(clap::value_parser!(String)),
        )
        .arg(
            Arg::new("image")
                .long("image")
                .value_name("FILE")
                .help("Path to the output image")
                .required(true)
                .value_parser(clap::value_parser!(String)),
        )
        .arg(
            Arg::new("height")
                .long("height")
                .value_name("NUMBER")
                .help("Number of height of the recovered image")
                .required(true)
                .value_parser(clap::value_parser!(u32)),
        )
        .arg(
            Arg::new("width")
                .long("width")
                .value_name("NUMBER")
                .help("Number of width of the recovered image")
                .required(true)
                .value_parser(clap::value_parser!(u32)),
        )
        .arg(
            Arg::new("decompress")
                .short('d')
                .long("decompress")
                .help("Decompress pixel data back to 8 bits")
                .action(ArgAction::SetTrue),
        )
        .get_matches();

    let decompress = matches.get_flag("decompress");
    let height = matches.get_one::<u32>("height").unwrap();
    let width = matches.get_one::<u32>("width").unwrap();
    let csv_input = matches.get_one::<String>("decrypted-outputs").unwrap();
    let im_file = matches.get_one::<String>("image").unwrap();
    
    reconstruct_image(csv_input, *width, *height, decompress, im_file);
}
